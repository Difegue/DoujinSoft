<div id="game-modal" class="modal">
    <div class="modal-content" style="position: unset;">
        <h4 id="player-title" style="font-family: warioware" class="black-text">Game Name</h4>

        <div style="position: relative;" class="player-canvas">
            <canvas id="canvas-game" width="1920" height="1280"></canvas>
            <div id="animation-overlay" style="position: absolute; bottom: 0; width:100%; height: 100%; opacity: 0.2;">
                <img id="truck-player" src="./img/diy-car.svg" class="animate__animated"
                    style="position: absolute; top: 52%; left: 35%; width: 25%; height: 25%;">
                <img src="./img/bg_player.png" style="height:100%; width: 100%" />
            </div>
        </div>

    </div>
    <div class="modal-footer" style="display: flex; padding: 6px 20px;">
        <div class="progress" style="width: 80%; display: inline-block; margin-right: 15px; margin-top: 15px;">
            <div class="determinate" id="game-timer"></div>
        </div>
        <a href="#!" id="replay-button" class="modal-action waves-effect waves-green btn-flat"
            style="margin-left: auto; margin-top: 0;" onclick="replayGame()">Replay</a>
        <span id="score-counter" style="margin-left: auto; margin-top: -8px;text-align: center;">Score:<br>
            <span id="score-number">255</span>
        </span>
        <a href="#!" class="modal-action modal-close waves-effect waves-green btn-flat"
            style="margin-left: auto; margin-top: 0;">Close</a>
    </div>
</div>

<div id="nsfw-modal" class="modal">
    <div class="modal-content">
        <h4 style="font-family: warioware" class="black-text">NSFW Content heads-up</h4>
        <p class="black-text">
            This microgame has been flagged as containing R18 content. Do you still want to play it?<br>
            You can choose to only reveal this once, or to always reveal NSFW content.
        </p>
    </div>
    <div class="modal-footer">
        <a href="#!" id="replay-button" class="modal-action waves-effect waves-green btn-flat"
            style="margin-left: auto; margin-top: 0;" onclick="bypassNsfwCheck(false)">Only this time!</a>
        <a href="#!" id="replay-" class="modal-action waves-effect waves-green btn-flat"
            style="margin-left: auto; margin-top: 0;" onclick="bypassNsfwCheck(true)">Don't show this warning again</a>
        <a href="#!" class="modal-action modal-close waves-effect waves-green btn-flat"
            style="margin-left: auto; margin-top: 0;">Cancel</a>
    </div>
</div>

<!-- TODO move to a js file -->
<script>

    var isInitialised = false;
    var mioData = null;
    var midiData = null;

    var canvas = document.getElementById('canvas-game');
    var context = canvas.getContext('2d');

    var lives;
    var score;
    var isPlayingCollection = false;
    var hasTrackEnded = false;
    var lostLastGame = false;

    var mioPlayer = new window.mio.Player(canvas, document);
    const loadSound = (name) => {
        let audio = new Audio('audio/' + name + '.ogg');
        audio.volume = 1;
        return audio;
    };

    var sounds = [];
    mioPlayer.soundNames.forEach(name => {
        let audio = loadSound(name);
        sounds.push(audio);
    });

    $('#game-modal').modal({
        dismissible: true,
        onCloseEnd: function () {
            context.clearRect(0, 0, canvas.width, canvas.height);
            player.pause();
            mioPlayer.stop();

            if (isPlayingCollection) {
                isPlayingCollection = false;
                $("#replay-button").show();
                $("#score-counter").hide();
            }
        }
    });

    $('#nsfw-modal').modal({
        dismissible: true
    });

    var winSounds = [loadSound('win1'), loadSound('win2')];
    var loseSounds = [loadSound('lose1'), loadSound('lose2')];

    mioPlayer.scaleCanvas(bestPossibleWindowSize());
    // Adjust the size of the overlay
    $('.player-canvas').css('height', canvas.height + 9);
    $('.player-canvas').css('width', canvas.width + 9);

    // re-scale canvas when the window size changes
    window.addEventListener('resize', function () {
        // Expand the canvas so the modal is expanded too.
        canvas.width = 1920;
        canvas.height = 1280;
        mioPlayer.scaleCanvas(bestPossibleWindowSize());

        // Adjust the size of the overlay
        $('.player-canvas').css('height', canvas.height + 9);
        $('.player-canvas').css('width', canvas.width + 9);
    });

    function modalSize() {
        return [$('#game-modal').width() - 48, $('#game-modal').height() - 108]; // Account for padding
    }

    function windowSizeComparedToOriginal(width, height) {
        return Math.min(width / window.mio.ORIGINAL_CANVAS_WIDTH, height / window.mio.ORIGINAL_CANVAS_HEIGHT);
    }

    function bestPossibleWindowSize() {
        let [width, height] = modalSize();
        return windowSizeComparedToOriginal(width, height);
    }

    let tempHash = null;
    let tempTitle = null;
    function createModal(gameHash, gameTitle, isNsfw) {
        if (isNsfw && !localStorage.hasOwnProperty("disabledNsfwCheck")) {
            tempHash = gameHash;
            tempTitle = gameTitle;
            $('#nsfw-modal').modal('open');
        } else {
            startMioPlayer(gameHash, gameTitle);
        }
    }

    function bypassNsfwCheck(permanentlyDisable) {
        $('#nsfw-modal').modal('close');
        if (permanentlyDisable) {
            localStorage.disabledNsfwCheck = true;
            $(".game-blur").remove();
        }
        startMioPlayer(tempHash, tempTitle);
    }

    async function startMioPlayer(gameHash, gameTitle) {
        $('#game-modal').modal('open');

        // TODO change this to use the player's data when we can
        $("#player-title").text(gameTitle);
        $("#score-counter").hide();

        mioData = await _fetch('./download?type=game&id=' + gameHash);
        playGame(mioData);
    }

    function setAnimation(animationClass) {
        $("#truck-player").attr('class', 'animate__animated');
        $("#truck-player").addClass(animationClass);
    }

    function animationEnd() {
        // Wait for "animationend" event
        return new Promise(resolve => {
            $("#truck-player").on('animationend', resolve);
        });
    }

    async function startCollectionPlayer(gameHashes) {
        isPlayingCollection = true;
        $("#replay-button").hide();
        $("#score-counter").show();
        $("#score-number").html(score);
        lives = 4;
        score = 0;

        $('#game-modal').modal('open');

        let nextGame;
        let firstGame = _fetch('./download?type=game&id=' + gameHashes[0]);

        // Intro animation while fetching first game
        setAnimation('animate__bounceInLeft');
        await animationEnd();
        setAnimation('animate__rubberBand');
        await animationEnd();

        // Collection gameplay loop
        mioData = await firstGame;

        while (isPlayingCollection) {

            // animate__bounce + animate__bounceOutRight         
            setAnimation('animate__bounce');
            await animationEnd();
            setAnimation('animate__bounceOutRight');
            await animationEnd();

            playGame(mioData);

            // Wait for "playing" event to hide mask
            await new Promise(resolve => {
                mioPlayer.on('playing', resolve);
            });

            // Animate opacity of animation-overlay to 0
            $("#animation-overlay").css('opacity', 0);
            $("#animation-overlay").hide();

            // Pick a random hash
            let gameHash = gameHashes[Math.floor(Math.random() * gameHashes.length)];

            // Download the next game while the current one is playing
            console.log("Fetching next game " + gameHash);
            nextGame = _fetch('./download?type=game&id=' + gameHash).catch(e => {
                console.log("Error fetching next game: " + e);
                // Pick another hash and retry
                gameHash = gameHashes[Math.floor(Math.random() * gameHashes.length)];
                nextGame = _fetch('./download?type=game&id=' + gameHash);
            });

            // Wait for mioPlayer's 'ended' event
            await new Promise(resolve => {
                mioPlayer.on('ended', resolve);
            });

            $("#animation-overlay").show();
            $("#animation-overlay").css('opacity', 1);

            if (!isPlayingCollection) break;

            // Check win/lose status
            score++;
            $("#score-number").html(score);
            if (lostLastGame) {
                $("#player-title").text("Oh no!");
                lives--;

                // animate__lightSpeedInLeft + animate__rotateOut + animate__bounceInDown
                setAnimation('animate__lightSpeedInLeft');
                await animationEnd();
                setAnimation('animate__rotateOut');
                await animationEnd();
                setAnimation('animate__bounceInDown');
                await animationEnd();
            } else {

                $("#player-title").text("Nice!");

                // animate__zoomInLeft + animate__heartBeat 
                setAnimation('animate__zoomInLeft');
                await animationEnd();
                setAnimation('animate__heartBeat');
                await animationEnd();
            }

            if (lives <= 0) {
                $("#player-title").text("Game Over");
                isPlayingCollection = false;

                // animate__hinge
                setAnimation('animate__hinge');
                await animationEnd();

                break;
            }

            // Wait for the next game to be downloaded
            mioData = await nextGame;
        }

    }

    function handleMouseMove(event) {
        if (typeof canvas !== 'undefined') {
            mioPlayer.setStylusPosition(event.clientX, event.clientY);
        }
    }

    function handleMouseDown(event) {
        if (event.button === 0) {
            mioPlayer.touchScreen();
        }
    }

    function handleMouseUp(event) {
        if (event.button === 0) {
            mioPlayer.withdrawTouchFromScreen();
        }
    }

    function handleTouchStart(event) {
        if (typeof canvas !== 'undefined') {
            let touch = event.touches[0] || event.changedTouches[0];
            mioPlayer.setStylusPosition(touch.clientX, touch.clientY);
        }
        mioPlayer.touchScreen();
    }

    function handleTouchEnd() {
        mioPlayer.withdrawTouchFromScreen();
    }

    // _fetch function taken from timidity by Feross Aboukhadijeh
    // https://github.com/feross/timidity
    async function _fetch(url) {
        const opts = {
            mode: 'cors',
            credentials: 'same-origin'
        }
        const response = await window.fetch(url, opts)
        if (response.status !== 200) throw new Error(`Could not load ${url}`)

        const arrayBuffer = await response.arrayBuffer()
        const buf = new Uint8Array(arrayBuffer)
        return buf
    }

    function playGame(mioData) {
        let loopTimes;

        if (mioData[0xE605] === 0) {
            loopTimes = 0;
        } else if (mioData[0xE605] === 1) {
            loopTimes = 1;
        } else {
            loopTimes = 11;
        }
        midiData = window.buildMidiFile(mioData, loopTimes);

        player.load(midiData);

        if (!isInitialised) {
            initializeMioPlayer();
        }

        mioPlayer.loadAndStart(mioData);
    }

    function initializeMioPlayer() {
        mioPlayer.sounds = sounds;
        mioPlayer.winSounds = winSounds;
        mioPlayer.loseSounds = loseSounds;

        // current frame and the final frame in which the game will end: i.e. 240 for SHORT, 480 for LONG and undefined for BOSS
        mioPlayer.on('frameupdate', (frame, endFrame) => {

            // Update game-timer div
            if (endFrame === undefined) {
                $("#game-timer").attr("class", "indeterminate");
            }
            else {
                $("#game-timer").attr("class", "determinate");
                $("#game-timer").attr("style", "width:" + (100 - (frame / endFrame * 100)) + "%");
            }
        });

        mioPlayer.on('won', () => lostLastGame = false);
        mioPlayer.on('lost', () => lostLastGame = true);

        document.addEventListener('mousemove', handleMouseMove, false);
        canvas.addEventListener('mousedown', handleMouseDown, false);
        document.addEventListener('mouseup', handleMouseUp, false)

        canvas.addEventListener('touchstart', handleTouchStart, false);
        document.addEventListener('touchend', handleTouchEnd, false);

        player.on('ended', () => { hasTrackEnded = true; });

        mioPlayer.musicPlayer = {
            playMusic: () => {
                player.pause();
                player.seek(0);
                player.play();
                hasTrackEnded = false;
            },
            pauseMusic: () => player.pause(),
            hasTrackEnded: () => hasTrackEnded,
        };

        let fontBitmap = new Image();
        fontBitmap.src = 'img/miofont.png';

        mioPlayer.fontBitmap = fontBitmap;

        isInitialised = true;
    }

    function replayGame() {
        player.pause();
        player.load(midiData);
        mioPlayer.loadAndStart(mioData);
    }

</script>